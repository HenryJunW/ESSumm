And um then just use that in a very simple HMM
What are {disfmarker} what are your f uh frame error rates for {disfmarker} for this ?
Uh , clean TI - digits is , like , pretty pristine {vocalsound} training data ,
But you have the distances to work with .
You get {disfmarker} you get either a zero or a one .
That 's pretty bad .
well I {vocalsound} tried this mean subtraction method .
you know , there 's more things it 's considering
You know . The idea is with a {disfmarker} with a very simple statistical structure , could you {disfmarker} could you uh at least verify that you 've chosen features that {vocalsound} are sufficient .
So . I {disfmarker} I guess some of the progress , I {disfmarker} I 've been getting a {disfmarker} getting my committee members for the quals .
then , you know , will it work on a {disfmarker} {vocalsound} on a {disfmarker} on a good system .
Well , it says , since you 're taking a natural log , it says that when {disfmarker} when you get down to essentially zero energy , this is gonna be the natural log of one , which is zero .
Should be in nineties somewhere .
Is that some kind of base conversion ,
because the difference in performance is {disfmarker} it 's not gigantic
so I 'm gonna {vocalsound} do a similar thing with {disfmarker} {vocalsound} with support vector machines
I don't remember for voice - unvoice ,
and other one that have fifty - six output .
And you just took this thing in here because it 's a neural net and neural nets are wonderful
So if it 's {disfmarker} if it 's um {disfmarker} if it 's low energy uh but the {disfmarker} but the spectrum looks like that or like that , it 's probably silence .
and {vocalsound} you told me that there was a difference in how the normalization was done .
He did one PZM channel and one PDA channel .
So , since he used the same exact pruning thresholds for both , I was wondering if it could be that we 're getting more pruning .
yeah the Aurora system with the new filter , VAD or something like that .
um {vocalsound} where I just used the simulated impulse response um {vocalsound} the error rate went from something like eighty it was from something like eighteen percent {vocalsound} to um four percent .
Yeah , they {disfmarker} {vocalsound} they had a {disfmarker} had a way to translate the distances into {disfmarker} into probabilities with the {disfmarker} with the simple {vocalsound} um {vocalsound} uh sigmoidal function .
I it can be a {disfmarker} a reduced um {vocalsound} parameterization of {disfmarker} of the {disfmarker} the model by just keeping {vocalsound} certain selected examples .
This is for the other one .
the {disfmarker} with the new code .
We don't have any set of parameters where we can say you know , " only process from you know a hundred and ten hertz to thirty - seven - fifty " .
And so I 'm gonna apply that to {vocalsound} um compare it with the results by um King and Taylor who did {vocalsound} um these
Given this {disfmarker} this uh regular old net that 's just for choosing for other purposes , uh add up the probabilities of the different subclasses and see {disfmarker} see how well you do .
See , because it {disfmarker} because this is {disfmarker} this is just like a single number to tell you um " does the spectrum look like that or does it look like that " .
what it {disfmarker} i at the end of the day , what it actually does is {vocalsound} it picks {vocalsound} those examples of the features that are closest to the separating boundary ,
than for the mel cepstral stuff , and that the average amount of pruning that was happening was therefore a little bit higher for the PLP features .
I mean , to first order , um
And this sort of smooths it for very small energies .
The inputs are the fifteen {disfmarker} the fifteen uh bases feature .
So I 'm {disfmarker} I {disfmarker} I just need to ask um Malek .
and maybe it has something to do with the fact that this is {disfmarker}
and {disfmarker} {vocalsound} and uses them to recreate the boundary for the test set .
and just count the co - occurrences and divide them by the {disfmarker} the uh {disfmarker} uh uh occ uh count the co - occurrences between the event and the phone and divide them by the number of occurrences of the phone ,
The {disfmarker} the other thing I was suggesting , though , is that given that you 're talking about binary features , uh , maybe the first thing to do is just to count
and um {vocalsound} {vocalsound} we 're {disfmarker} we 're {disfmarker} we 're {vocalsound} thinking about a way to test the completeness of a {disfmarker} a set of um dynamic uh events .
and I asked John Ohala and he agreed .
and also mmm I {disfmarker} H Hynek last week say that if I have time I can to begin to {disfmarker} to study
uh and we see some reduction in error using some clever method ,
O one thing I 'm wondering about is what this mean subtraction method {vocalsound} um will do if it 's faced with additive noise .
uh What about it you skip all the {disfmarker} all the really clever things , and just fed the log magnitude spectrum into this ?
So i i the idea is if we get good phone recognition results , {vocalsound} using um these set of acoustic events , {vocalsound} then {vocalsound} um that {disfmarker} that says that these acoustic events are g sufficient to cover {vocalsound} a set of phones ,
yeah one of the differences between voiced , unvoiced and silence is energy .
and uh count co - occurrences and get probabilities for a discrete HMM
And I put together the fifteen features and the three MLP output .
So for my class project I 'm {vocalsound} um {vocalsound} {vocalsound} I 'm tinkering with uh support vector machines ?
If you just do this by counting , then you should be able to find out in a pretty straightforward way whether you have a sufficient uh set of events to {disfmarker} to do the kind of level of {disfmarker} {vocalsound} of uh classification of phones that you 'd like .
Then in that case , if you have two nets ,
So one thing that I did notice , yesterday I was studying the um {disfmarker} the uh RASTA code
But I mean you could {disfmarker} uh if {disfmarker} if {disfmarker} if that looks promising you could , you know , r uh run {vocalsound} the overall test set with a {disfmarker} with a few different uh pruning thresholds for both ,
And I 'm trying two MLP , one one that only have t three output ,
And the uh the {disfmarker} the run time of the recognizer on the PLP features is longer
So y you 're restricted to being positive .
And I then {disfmarker} then I move to the next frame and I {disfmarker} {vocalsound} I do it again .
and uh you could uh do phone recognition then and uh wouldn't have any of the issues of the uh training of the net or {disfmarker}
because it 's just {disfmarker} Say , if you had ten {disfmarker} ten events , uh that you were counting , uh each frame would only have a thousand possible values for these ten bits ,
the first coefficient of the auto - correlation function .
That I look in the {disfmarker} with the other {disfmarker} nnn the other MLP that we have are more or less the same number .
and made a mapping from the MFCC 's to these phonological features ,
I {disfmarker} I 'm g I 'm guessing it was the {disfmarker} the training data .
I don't know why they have some constant in the expression of the lower energy .
So probably it should be something we should try then is to {disfmarker} is to see if {disfmarker} is {vocalsound} at some point just to take {disfmarker} i to transform the data
What features does it see ?
and so R - one over R - zero is what you typically use for that .
using recurrent neural nets , they recognized {vocalsound} um {vocalsound} a set of phonological features
voice , unvoice , and silence ,
But I don't know what is the meaning of take exactly this value .
I mean {vocalsound} the fundamental d d difference that we 've seen any kind of difference from before , which is actually an advantage for the P L P i uh , I think , is that the {disfmarker} the smoothing at the end is auto - regressive instead of being cepstral {disfmarker} uh , {comment} from cepstral truncation .
and it looks like we don't have any way to um control the frequency range that we use in our analysis .
Fif - fifty - six percent accurate for v voice - unvoice
but I was gonna ask about the {disfmarker} {vocalsound} the um {vocalsound} changes to the data in comparing PLP and mel cepstrum for the SRI system .
The probabilities of the allophone .
So rather than doing nearest neighbor where you compare to every single one , you just pick a few critical ones ,
what you can do is um you can definitely change the {disfmarker} the filter bank from being uh a uh trapezoidal integration to a {disfmarker} a {disfmarker} a triangular one ,
That is like the energy with these three feature ,
if you were to sum up the probabilities for the voiced and for the unvoiced and for the silence here , we 've found in the past you 'll do better at voiced - unvoiced - silence than you do with this one .
Another one is {disfmarker} but the other one is the spectral shape .
but it 's big enough that it {disfmarker} it seems wrong .
Mmm , one day or less .
and then {disfmarker} {vocalsound} and then uh use th use it for the SRI system .
And um so far I have Morgan and Hynek , {vocalsound} Mike Jordan ,
So , it seems to me that the only reasonable starting point is uh to automatically translate the uh current TIMIT markings into the markings you want .
And on meeting rec recorder far mike digits , mike {disfmarker} on channel F , it went from um {vocalsound} {vocalsound} forty - one percent error to eight percent error .
you know , if {disfmarker} uh uh the example I was giving was that if {disfmarker} if you had um onset of voicing and {disfmarker} and end of voicing as being two kinds of events , then if you had those a all marked correctly , and you counted co - occurrences , you should get it completely right .
I think it was about five percent error for the PZM channel .
So if you just {disfmarker} if you just had to pick two features to determine voiced - unvoiced , you 'd pick something about the spectrum like uh R - one over R - zero , um and R - zero
but then you have something like spectral slope , which is you get like R - one ov over R - zero or something like that .
Well , actually I calculate all the means first
but that might not be the right number .
um {vocalsound} I 'm using two second {vocalsound} FFT analysis frames , {vocalsound} stepped by a half second
but if you just say " what is {disfmarker} "
So just having the three output thing doesn't {disfmarker} doesn't really buy you anything .
And so Morgan and I were uh discussing {vocalsound} um s uh s a form of a cheating experiment {vocalsound} where we get {disfmarker} {vocalsound} um we have uh {vocalsound} um a chosen set of features , or acoustic events ,
Yeah , because it 's noise also .
If you 're getting fifty - six here , try adding together the probabilities of all of the voiced phones here and all of the unvoiced phones
And then the other thing that we were discussing was {disfmarker} was um {vocalsound} OK , how do you get the {disfmarker} your training data .
I think , given at the level you 're doing things in floating point on the computer , I don't think it matters , would be my guess ,
Um so i it would be a {disfmarker} {vocalsound} a measure of " are we on the right track with {disfmarker} with the {disfmarker} the choices of our acoustic events " .
We have noisy TIMIT with the noise of the {disfmarker} the TI - digits .
which goes along with the fact that the matches aren't as good .
So what 's the advantage of support vector machines ?
One of the things that I did notice was that the um log likelihoods coming out of the log recognizer from the PLP data were much lower , much smaller ,
and hopefully there should be some point at which {vocalsound} having more information doesn't tell you really all that much more about what the phones are .
Well eh you know that I work {disfmarker} I begin to work with a new feature to detect voice - unvoice .
What I trying two MLP to {disfmarker} to the {disfmarker} with this new feature and the fifteen feature uh from the eh bus base system
and figure out what they can {disfmarker} what they most need from things , and I mean that 's what they 're good at .
um {disfmarker} But you 'd get all the other distinctions , you know , randomly wrong .
Yeah , w we 're often asked this when we work with a system that {disfmarker} that isn't {disfmarker} isn't sort of industry {disfmarker} industry standard great ,
and that would give you the likelihood of the {disfmarker} of the event given the phone .
and then it finds the optimal separating plane , um between these two different um classes ,
fifty - six , or something ,
and remembers those
well it seems like there 's a bug ,
Um . So , support vector machines are {disfmarker} are good with dealing with a less amount of data
f so for every phone there is {disfmarker} there is a um {disfmarker} a vector of ones and zeros {vocalsound} f uh corresponding to whether it exhibits a particular phonological feature or not .
Yeah , so the idea is that the very lowest frequencies and {disfmarker} and typically the veriest {comment} highest frequencies are kind of junk .
I think that {disfmarker} I {disfmarker} I {disfmarker} I think that for the other one , for the three output , is sixty sixty - two , sixty three more or less .
I use that to normalize the s the current center frame {vocalsound} by mean subtraction .
Oh , at the front it says uh " log energy is equal to the rounded version of sixteen over the log of two "
and we train up a hybrid {vocalsound} um system to do phone recognition on TIMIT .
you just {disfmarker} for continuity you just approximate them by {disfmarker} {vocalsound} by the second to highest and second to lowest .
Due to Avendano , {vocalsound} I 'm taking s um {vocalsound} six seconds of speech ,
And I was asking if you were going to do {disfmarker} {vocalsound} redo it uh for PLP with the normalization done as it had been done for the mel cepstrum .
and uh so you could make a table that would {disfmarker} say , if you had thirty - nine phone categories , that would be a thousand by thirty - nine ,
So , {vocalsound} the {disfmarker} the simple idea behind a support vector machine is {vocalsound} um , {vocalsound} you have {disfmarker} you have this feature space ,
But the first thing that I don't understand is that they are using R - the uh log energy that this quite {disfmarker}
I 'm just doing {vocalsound} detection of phonological features .
So why were you getting forty - one here ?
So , given these {vocalsound} um these features , or {disfmarker} or these {disfmarker} these examples , {pause} um , {pause} critical examples , {vocalsound} which they call support f support vectors , {vocalsound} then um {vocalsound} given a new example , {vocalsound} if the new example falls {vocalsound} um away from the boundary in one direction then it 's classified as being a part of this particular class
How long does it take , Carmen , to train up one of these nets ?
Right , but it seemed to me that what you were what you were getting at before was that there is something about the difference between the original signal or the original FFT and with the filter which is what {disfmarker}
Uh but if it 's low energy and the spectrum looks like that , it 's probably unvoiced .
Then uh I talked a little bit about {vocalsound} um continuing with these dynamic ev um acoustic events ,
Well , this is natural log ,
So I was going through and just double - checking that kind of think first , to see if there was just some kind of obvious bug in the way that I was computing the features .
Uh , completeness in the {disfmarker} in the sense that {vocalsound} um if we {disfmarker} if we pick these X number of acoustic events , {vocalsound} do they provide sufficient coverage {vocalsound} for the phones that we 're trying to recognize {vocalsound} or {disfmarker} or the f the words that we 're gonna try to recognize later on .
And I tried to do some experiment of recognition with that
And , well , the result are li a little bit better , but more or less similar .
I was wondering if there 's maybe um {vocalsound} certain settings of the parameters when you compute PLP which would basically cause it to output mel cepstrum .
and the variance was one take uh on it .
Actually you don't get a {disfmarker} you don't get a nice number between zero and one .
basically it 's to learn a mapping {vocalsound} from {disfmarker} {vocalsound} from the MFCC 's to {vocalsound} uh phonological features .
well seriously the France Telecom proposal
So the particular measure that she chose was the variance of this m of this difference ,
and only have result with {disfmarker} with the MLP with the three output .
Cuz I {disfmarker} I {disfmarker} it 's cuz I don't know what log magnitude spectral subtraction is gonna do to additive noise .
And what I was saying is that the only thing I think that it buys you is um based on whether you feed it something different .
And so the kind of thing that {disfmarker} that she was talking about before , was looking at something uh ab um {disfmarker} something uh about the difference between the {disfmarker} the uh um log FFT uh log power uh and the log magnitude uh F F - spectrum uh and the um uh filter bank .
and then I do the subtraction .
Alright , and this one has three outputs , and this one has f
which sort of implies that the networks are bushier ,
the variance of the auto - correlation function , except the {disfmarker} the first point , because half the height value is R - zero
OK , so it 's then {disfmarker} then it 's {disfmarker} it 's {disfmarker} it 's reasonable to expect it would be helpful if we used it with the SRI system
